<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Questionário Interativo de SQL</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .correct {
            background-color: #16a34a !important; /* green-600 */
            color: white !important;
            border-color: #16a34a !important;
        }
        .incorrect {
            background-color: #dc2626 !important; /* red-600 */
            color: white !important;
            border-color: #dc2626 !important;
        }
        .btn:disabled {
            cursor: not-allowed;
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 flex items-center justify-center min-h-screen p-4">

    <div id="quiz-container" class="w-full max-w-2xl bg-white dark:bg-gray-800 rounded-2xl shadow-lg p-6 md:p-8">
        <div id="start-screen" class="text-center">
            <h1 class="text-3xl font-bold text-gray-900 dark:text-white mb-4">Questionário de Revisão de SQL</h1>
            <p class="text-gray-600 dark:text-gray-300 mb-8">Teste seus conhecimentos com 35 questões sobre os principais comandos de SQL.</p>
            <button id="start-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition-transform transform hover:scale-105">Começar!</button>
        </div>

        <div id="quiz-screen" class="hidden">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-gray-900 dark:text-white">Questão <span id="question-number">1</span>/<span id="total-questions">35</span></h2>
                <div id="score" class="text-lg font-semibold text-blue-600 dark:text-blue-400">Pontos: 0</div>
            </div>
            
            <div id="question-box" class="mb-6">
                <p id="question-text" class="text-lg text-gray-700 dark:text-gray-300 mb-6 min-h-[6rem] flex items-center"></p>
                <div id="answer-buttons" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <!-- Buttons will be inserted by JS -->
                </div>
            </div>

            <div id="feedback" class="text-center font-medium mt-4 min-h-[1.5rem]">&nbsp;</div>
            
            <div class="mt-6 text-center">
                <button id="next-btn" class="hidden w-1/2 bg-gray-700 hover:bg-gray-800 text-white font-bold py-3 px-6 rounded-lg text-lg transition-transform transform hover:scale-105">Próxima</button>
            </div>
        </div>

        <div id="results-screen" class="hidden text-center">
             <h1 class="text-3xl font-bold text-gray-900 dark:text-white mb-4">Quiz Finalizado!</h1>
             <p id="results-text" class="text-2xl text-gray-700 dark:text-gray-300 mb-2">Você acertou 0 de 35 questões.</p>
             <p id="percentage-text" class="text-4xl font-bold text-blue-600 dark:text-blue-400 mb-8">0% de acerto</p>
             <button id="restart-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition-transform transform hover:scale-105">Tentar Novamente</button>
        </div>

    </div>

    <script>
        const questions = [
            { question: "Qual é a principal função da cláusula `WHERE` em uma instrução `SELECT`?", answers: [ { text: "Ordenar os resultados da consulta.", correct: false }, { text: "Agrupar os resultados com base em uma coluna.", correct: false }, { text: "Filtrar as linhas retornadas pela consulta com base em uma condição.", correct: true }, { text: "Juntar dados de duas ou mais tabelas.", correct: false } ] },
            { question: "Ao usar um `LEFT JOIN` da Tabela A para a Tabela B, o que acontece se um registro da Tabela A não tiver um correspondente na Tabela B?", answers: [ { text: "O registro da Tabela A não é exibido no resultado.", correct: false }, { text: "Ocorre um erro na consulta.", correct: false }, { text: "O registro da Tabela A é exibido, e as colunas da Tabela B ficam com o valor `NULL`.", correct: true }, { text: "Apenas os registros que existem em ambas as tabelas são exibidos.", correct: false } ] },
            { question: "A cláusula `GROUP BY` é utilizada para:", answers: [ { text: "Ordenar o resultado final de uma consulta em ordem alfabética.", correct: false }, { text: "Agrupar linhas que têm os mesmos valores em colunas especificadas em um conjunto de resumo.", correct: true }, { text: "Adicionar novas linhas a uma tabela.", correct: false }, { text: "Filtrar os resultados de uma consulta antes do agrupamento.", correct: false } ] },
            { question: "Qual a principal diferença entre os operadores `UNION` e `UNION ALL`?", answers: [ { text: "`UNION` não permite combinar mais de duas tabelas, enquanto `UNION ALL` permite.", correct: false }, { text: "`UNION` remove linhas duplicadas do resultado final, enquanto `UNION ALL` inclui todas as linhas, mesmo as duplicadas.", correct: true }, { text: "`UNION ALL` é usado para tabelas com tipos de dados diferentes, enquanto `UNION` exige tipos de dados idênticos.", correct: false }, { text: "`UNION` é mais rápido que `UNION ALL` porque não verifica duplicatas.", correct: false } ] },
            { question: "O que é uma `VIEW` em um banco de dados?", answers: [ { text: "Uma cópia física e completa de uma tabela, usada para backup.", correct: false }, { text: "Uma tabela temporária que só existe durante a sessão do usuário.", correct: false }, { text: "Uma consulta `SELECT` armazenada que se comporta como uma tabela virtual.", correct: true }, { text: "Um índice para acelerar as consultas em uma tabela.", correct: false } ] },
            { question: "Qual das seguintes afirmações melhor descreve uma `Stored Procedure`?", answers: [ { text: "É um gatilho que é executado automaticamente quando os dados são modificados.", correct: false }, { text: "É uma tabela temporária usada para armazenar resultados intermediários.", correct: false }, { text: "É um conjunto de comandos SQL pré-compilados e armazenados no banco de dados que podem ser executados como uma única unidade.", correct: true }, { text: "É uma restrição usada para garantir a integridade dos dados em uma tabela.", correct: false } ] },
            { question: "Um `TRIGGER` (gatilho) em SQL é um procedimento especial que é executado automaticamente quando:", answers: [ { text: "Um usuário se conecta ao banco de dados.", correct: false }, { text: "Uma consulta `SELECT` é executada em uma tabela.", correct: false }, { text: "Ocorre um evento específico, como um `INSERT`, `UPDATE` ou `DELETE` em uma tabela.", correct: true }, { text: "Um backup do banco de dados é concluído.", correct: false } ] },
            { question: "Qual comando é usado para garantir que apenas valores únicos sejam inseridos em uma coluna específica de uma tabela, permitindo valores `NULL`?", answers: [ { text: "`CHECK`", correct: false }, { text: "`UNIQUE`", correct: true }, { text: "`PRIMARY KEY`", correct: false }, { text: "`FOREIGN KEY`", correct: false } ] },
            { question: "Para armazenar valores monetários, qual dos seguintes tipos de dados seria o mais apropriado para garantir a precisão?", answers: [ { text: "`FLOAT`", correct: false }, { text: "`INT`", correct: false }, { text: "`DECIMAL` ou `NUMERIC`", correct: true }, { text: "`VARCHAR`", correct: false } ] },
            { question: "Qual comando é usado para salvar permanentemente todas as alterações feitas em uma transação?", answers: [ { text: "`ROLLBACK TRAN`", correct: false }, { text: "`BEGIN TRAN`", correct: false }, { text: "`SAVE TRAN`", correct: false }, { text: "`COMMIT TRAN`", correct: true } ] },
            { question: "Em qual situação a cláusula `HAVING` deve ser usada em vez da cláusula `WHERE`?", answers: [ { text: "Para filtrar linhas com base em valores de colunas individuais antes de qualquer cálculo.", correct: false }, { text: "Para ordenar o resultado de uma consulta.", correct: false }, { text: "Para filtrar grupos de linhas que não atendem a uma condição baseada em uma função de agregação (como `SUM()`, `COUNT()`, etc.).", correct: true }, { text: "Para juntar duas tabelas que não possuem uma chave estrangeira em comum.", correct: false } ] },
            { question: "Uma subconsulta que retorna um único valor (uma única coluna e uma única linha) é chamada de:", answers: [ { text: "Subconsulta escalar.", correct: true }, { text: "Subconsulta de múltiplas linhas.", correct: false }, { text: "Subconsulta correlacionada.", correct: false }, { text: "Subconsulta de múltiplas colunas.", correct: false } ] },
            { question: "Qual das seguintes afirmações sobre uma `PRIMARY KEY` (Chave Primária) é **falsa**?", answers: [ { text: "Ela identifica unicamente cada registro em uma tabela.", correct: false }, { text: "Uma tabela pode ter múltiplas chaves primárias.", correct: true }, { text: "Por padrão, ela cria um índice clusterizado na tabela.", correct: false }, { text: "Ela não permite valores `NULL`.", correct: false } ] },
            { question: "No SQL Server, qual caractere precede o nome de uma tabela temporária local, que é visível apenas na sessão atual do usuário?", answers: [ { text: "`@` (Arroba)", correct: false }, { text: "`##` (Duas cerquilhas)", correct: false }, { text: "`&` (E comercial)", correct: false }, { text: "`#` (Uma cerquilha)", correct: true } ] },
            { question: "Qual função de agregação é usada para calcular a média de valores em uma coluna numérica?", answers: [ { text: "`SUM()`", correct: false }, { text: "`COUNT()`", correct: false }, { text: "`AVG()`", correct: true }, { text: "`MAX()`", correct: false } ] },
            { question: "Qual é a principal vantagem de usar parâmetros em uma `Stored Procedure`?", answers: [ { text: "Aumentar o tamanho do banco de dados.", correct: false }, { text: "Permitir que a procedure seja executada com diferentes valores de entrada, tornando-a reutilizável e dinâmica.", correct: true }, { text: "Garantir que a procedure só possa ser executada por um único usuário.", correct: false }, { text: "Tornar a execução da procedure mais lenta, porém mais segura.", correct: false } ] },
            { question: "Qual é uma potencial desvantagem do uso excessivo de `TRIGGERS` em um banco de dados?", answers: [ { text: "Eles melhoram a performance de todas as consultas `SELECT`.", correct: false }, { text: "Eles podem tornar a lógica do banco de dados mais difícil de entender e depurar, além de poderem impactar negativamente a performance de operações de `INSERT`, `UPDATE` e `DELETE`.", correct: true }, { text: "Eles eliminam a necessidade de criar `VIEWS`.", correct: false }, { text: "Eles não podem ser desabilitados temporariamente.", correct: false } ] },
            { question: "Qual é uma diferença fundamental entre `DELETE FROM tabela` e `TRUNCATE TABLE tabela`?", answers: [ { text: "`DELETE` remove todas as linhas, enquanto `TRUNCATE` remove apenas as linhas duplicadas.", correct: false }, { text: "`TRUNCATE` é uma operação que pode ser desfeita com `ROLLBACK`, enquanto `DELETE` não pode.", correct: false }, { text: "`DELETE` aciona `TRIGGERS` de `DELETE` para cada linha, enquanto `TRUNCATE` geralmente não.", correct: true }, { text: "`TRUNCATE` permite o uso da cláusula `WHERE`, enquanto `DELETE` não.", correct: false } ] },
            { question: "A instrução `CASE` em uma consulta `SELECT` é usada para:", answers: [ { text: "Criar uma tabela temporária.", correct: false }, { text: "Executar lógica condicional (if-then-else) para retornar valores diferentes com base em condições.", correct: true }, { text: "Excluir permanentemente uma tabela do banco de dados.", correct: false }, { text: "Iniciar uma transação.", correct: false } ] },
            { question: "Dentro de um `TRIGGER` de `UPDATE`, qual tabela virtual contém os dados **antes** da alteração ser aplicada?", answers: [ { text: "A tabela `updated`.", correct: false }, { text: "A tabela `inserted`.", correct: false }, { text: "A tabela `deleted`.", correct: true }, { text: "A tabela `original`.", correct: false } ] },
            { question: "Qual é o propósito principal de uma `FOREIGN KEY` (Chave Estrangeira)?", answers: [ { text: "Acelerar a performance das consultas de `SELECT`.", correct: false }, { text: "Garantir que cada linha da tabela seja única.", correct: false }, { text: "Criar um link entre duas tabelas e impor a integridade referencial.", correct: true }, { text: "Armazenar dados de outras tabelas de forma redundante.", correct: false } ] },
            { question: "Para que serve a criação de um `INDEX` (Índice) em uma coluna de uma tabela?", answers: [ { text: "Para garantir que a coluna não aceite valores `NULL`.", correct: false }, { text: "Para criptografar os dados da coluna.", correct: false }, { text: "Para acelerar a recuperação de dados durante consultas (`SELECT`).", correct: true }, { text: "Para executar automaticamente uma ação quando a coluna é atualizada.", correct: false } ] },
            { question: "No SQL Server, qual bloco de código é usado para capturar e tratar erros?", answers: [ { text: "`IF...ELSE`", correct: false }, { text: "`CASE...WHEN`", correct: false }, { text: "`BEGIN...END`", correct: false }, { text: "`TRY...CATCH`", correct: true } ] },
            { question: "Qual comando é usado para adicionar uma nova coluna `Email` a uma tabela `Clientes`?", answers: [ { text: "`UPDATE TABLE Clientes ADD COLUMN Email VARCHAR(100);`", correct: false }, { text: "`CREATE COLUMN Email ON Clientes;`", correct: false }, { text: "`ALTER TABLE Clientes ADD Email VARCHAR(100);`", correct: true }, { text: "`MODIFY TABLE Clientes ADD Email VARCHAR(100);`", correct: false } ] },
            { question: "Qual operador é usado para verificar se o valor de uma coluna é nulo?", answers: [ { text: "`= NULL`", correct: false }, { text: "`IS NULL`", correct: true }, { text: "`== NULL`", correct: false }, { text: "`NULL`", correct: false } ] },
            { question: "Qual tipo de `JOIN` retorna apenas as linhas que possuem valores correspondentes em **ambas** as tabelas?", answers: [ { text: "`LEFT JOIN`", correct: false }, { text: "`RIGHT JOIN`", correct: false }, { text: "`FULL OUTER JOIN`", correct: false }, { text: "`INNER JOIN`", correct: true } ] },
            { question: "O que a propriedade `IDENTITY(1,1)` em uma coluna do tipo `INT` faz?", answers: [ { text: "Define o valor padrão da coluna como 1.", correct: false }, { text: "Cria um valor inicial de 1 e o incrementa de 1 em 1 para cada nova linha (autoincremento).", correct: true }, { text: "Limita o valor máximo da coluna a 1.", correct: false }, { text: "Cria uma chave estrangeira para a coluna.", correct: false } ] },
            { question: "O que o comando `ROLLBACK TRAN` faz dentro de uma transação?", answers: [ { text: "Salva um ponto específico da transação.", correct: false }, { text: "Salva permanentemente as alterações no banco de dados.", correct: false }, { text: "Desfaz todas as alterações realizadas desde o início da transação.", correct: true }, { text: "Confirma apenas a última alteração feita na transação.", correct: false } ] },
            { question: "Qual a principal diferença entre um `TRIGGER AFTER` e um `TRIGGER INSTEAD OF`?", answers: [ { text: "`AFTER` executa antes da ação, e `INSTEAD OF` executa depois.", correct: false }, { text: "`AFTER` é usado em tabelas, e `INSTEAD OF` é usado em `VIEWS`.", correct: false }, { text: "`AFTER` executa após a ação. `INSTEAD OF` executa **em vez** da ação, substituindo-a.", correct: true }, { text: "`AFTER` não tem acesso às tabelas `inserted` e `deleted`.", correct: false } ] },
            { question: "Qual é uma funcionalidade exclusiva da função `CONVERT` em comparação com `CAST`?", answers: [ { text: "Converter números para texto.", correct: false }, { text: "Converter texto para datas.", correct: false }, { text: "Lidar com a formatação de datas e horas usando um parâmetro de estilo.", correct: true }, { text: "Converter números inteiros para decimais.", correct: false } ] },
            { question: "O que um backup **completo** (Full Backup) do banco de dados inclui?", answers: [ { text: "Apenas as alterações feitas desde o último backup completo.", correct: false }, { text: "Apenas o log de transações.", correct: false }, { text: "Uma cópia completa de todos os objetos e dados do banco de dados.", correct: true }, { text: "Apenas a estrutura das tabelas, sem os dados.", correct: false } ] },
            { question: "Um backup **diferencial** (Differential Backup) contém:", answers: [ { text: "Todas as alterações feitas desde o último backup **de qualquer tipo**.", correct: false }, { text: "Todas as alterações feitas desde o último backup **diferencial**.", correct: false }, { text: "Todas as alterações feitas desde o último backup **completo**.", correct: true }, { text: "Apenas o último registro inserido no log de transações.", correct: false } ] },
            { question: "Para qual finalidade principal é utilizado o backup do **Log de Transações**?", answers: [ { text: "Para reduzir o tamanho do banco de dados.", correct: false }, { text: "Para permitir a recuperação para um ponto específico no tempo (Point-in-Time Recovery).", correct: true }, { text: "Para fazer uma cópia apenas da estrutura das tabelas.", correct: false }, { text: "Para substituir a necessidade de backups completos.", correct: false } ] },
            { question: "Qual modelo de recuperação (`RECOVERY MODEL`) é um pré-requisito para realizar backups do Log de Transações?", answers: [ { text: "Apenas `SIMPLE`.", correct: false }, { text: "Apenas `FULL`.", correct: false }, { text: "`FULL` ou `BULK_LOGGED`.", correct: true }, { text: "`SIMPLE` ou `FULL`.", correct: false } ] },
            { question: "Ao restaurar uma sequência de backups, qual opção deve ser usada nos comandos `RESTORE` intermediários para permitir que mais backups sejam aplicados?", answers: [ { text: "`WITH RECOVERY`", correct: false }, { text: "`WITH REPLACE`", correct: false }, { text: "`WITH NORECOVERY`", correct: true }, { text: "`WITH STANDBY`", correct: false } ] }
        ];

        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');
        const nextBtn = document.getElementById('next-btn');

        const startScreen = document.getElementById('start-screen');
        const quizScreen = document.getElementById('quiz-screen');
        const resultsScreen = document.getElementById('results-screen');
        
        const questionText = document.getElementById('question-text');
        const answerButtons = document.getElementById('answer-buttons');
        const feedbackText = document.getElementById('feedback');
        
        const questionNumberText = document.getElementById('question-number');
        const totalQuestionsText = document.getElementById('total-questions');
        const scoreText = document.getElementById('score');

        const resultsTextElement = document.getElementById('results-text');
        const percentageTextElement = document.getElementById('percentage-text');

        let shuffledQuestions, currentQuestionIndex;
        let score = 0;

        startBtn.addEventListener('click', startQuiz);
        restartBtn.addEventListener('click', startQuiz);
        nextBtn.addEventListener('click', () => {
            currentQuestionIndex++;
            setNextQuestion();
        });

        function startQuiz() {
            score = 0;
            shuffledQuestions = questions.sort(() => Math.random() - 0.5);
            currentQuestionIndex = 0;
            scoreText.innerText = `Pontos: ${score}`;
            totalQuestionsText.innerText = questions.length;

            startScreen.classList.add('hidden');
            resultsScreen.classList.add('hidden');
            quizScreen.classList.remove('hidden');

            setNextQuestion();
        }

        function setNextQuestion() {
            resetState();
            showQuestion(shuffledQuestions[currentQuestionIndex]);
        }
        
        function showQuestion(question) {
            questionNumberText.innerText = currentQuestionIndex + 1;
            questionText.innerHTML = question.question;
            question.answers.forEach(answer => {
                const button = document.createElement('button');
                button.innerText = answer.text;
                button.classList.add('btn', 'w-full', 'p-4', 'border-2', 'border-gray-300', 'dark:border-gray-600', 'rounded-lg', 'text-left', 'hover:bg-gray-200', 'dark:hover:bg-gray-700', 'transition-colors', 'duration-200');
                if (answer.correct) {
                    button.dataset.correct = answer.correct;
                }
                button.addEventListener('click', selectAnswer);
                answerButtons.appendChild(button);
            });
        }
        
        function resetState() {
            nextBtn.classList.add('hidden');
            feedbackText.innerHTML = '&nbsp;';
            while (answerButtons.firstChild) {
                answerButtons.removeChild(answerButtons.firstChild);
            }
        }

        function selectAnswer(e) {
            const selectedBtn = e.target;
            const correct = selectedBtn.dataset.correct === "true";
            
            if (correct) {
                score++;
                scoreText.innerText = `Pontos: ${score}`;
                feedbackText.innerText = 'Resposta Correta!';
                feedbackText.classList.add('text-green-600');
                feedbackText.classList.remove('text-red-600');
            } else {
                feedbackText.innerText = 'Resposta Incorreta!';
                feedbackText.classList.add('text-red-600');
                feedbackText.classList.remove('text-green-600');
            }
            
            // Clear previous body classes before adding new ones
            document.body.classList.remove('correct', 'incorrect');
            
            Array.from(answerButtons.children).forEach(button => {
                setStatusClass(button, button.dataset.correct === "true");
                button.disabled = true;
            });

            if (shuffledQuestions.length > currentQuestionIndex + 1) {
                nextBtn.classList.remove('hidden');
            } else {
                // Delay showing results to let user see feedback
                setTimeout(showResults, 1000);
            }
        }

        function setStatusClass(element, correct) {
            clearStatusClass(element);
            if (correct) {
                element.classList.add('correct');
            } else {
                element.classList.add('incorrect');
            }
        }

        function clearStatusClass(element) {
            element.classList.remove('correct');
            element.classList.remove('incorrect');
        }

        function showResults() {
            quizScreen.classList.add('hidden');
            resultsScreen.classList.remove('hidden');
            const percentage = Math.round((score / questions.length) * 100);
            resultsTextElement.innerText = `Você acertou ${score} de ${questions.length} questões.`;
            percentageTextElement.innerText = `${percentage}% de acerto`;
        }
    </script>
</body>
</html>
